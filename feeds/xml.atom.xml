<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Geert's Notes - XML</title><link href="/" rel="alternate"></link><link href="/feeds/xml.atom.xml" rel="self"></link><id>/</id><updated>2020-01-17T12:00:00+01:00</updated><entry><title>XML with lxml and XPath</title><link href="/xml-xpath-intro.html" rel="alternate"></link><published>2020-01-17T12:00:00+01:00</published><updated>2020-01-17T12:00:00+01:00</updated><author><name>Geert Jongen</name></author><id>tag:None,2020-01-17:/xml-xpath-intro.html</id><summary type="html">&lt;p&gt;This post contains my notes on XML parsing in python using Xpath&lt;/p&gt;</summary><content type="html">&lt;h1&gt;XML&lt;/h1&gt;
&lt;p&gt;XML is a widely used format to transfer and store data. In my current job I had to develop a solution to parse complex nested XMLs
In this article i will try to describe the knowledge required to perform this task in python using the lxml library.&lt;/p&gt;
&lt;h2&gt;LXML&lt;/h2&gt;
&lt;p&gt;to parse with &lt;code&gt;lxml&lt;/code&gt; in pyton &lt;/p&gt;
&lt;p&gt;The goal is to convert an XML file into a tabular format so it can be used in Machine Learning algorithms.&lt;/p&gt;
&lt;p&gt;use &lt;code&gt;lxml.read_xml()&lt;/code&gt; to read the XML. I got an error saying that namespace was unknown. It happened that in the tutorial from the data provider they accidentally used two types of variables for the env.  By making sure that the namespace declaration contained the correct variable name solved this issue.&lt;/p&gt;
&lt;p&gt;Once lxml correctly reads in the XML you have a socalled &lt;code&gt;ElementTree&lt;/code&gt; this is the structure containing the full XML. In order to start searching for the relevant information you need to start at the &lt;code&gt;root&lt;/code&gt; of this tree. You do that by calling &lt;code&gt;root = tree.get_root()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;An &lt;code&gt;ElementTree&lt;/code&gt; consists of &lt;code&gt;Element&lt;/code&gt; objects. This is a container object that stores hierarchical data structure into memory. &lt;/p&gt;
&lt;p&gt;Each &lt;code&gt;Element&lt;/code&gt; has a number of properties, only 1. is obligatory:
1. a &lt;strong&gt;tag&lt;/strong&gt; a String which identifies what kind of data this element represents
2. a number of &lt;strong&gt;attributes&lt;/strong&gt; stored in a &lt;code&gt;dict&lt;/code&gt;
3. a &lt;strong&gt;text&lt;/strong&gt; string containing the text content between the &lt;code&gt;&amp;lt;tag&amp;gt; &amp;lt;/tag&amp;gt;&lt;/code&gt;
4. a number of &lt;strong&gt;child elements&lt;/strong&gt; stored in a python sequence&lt;/p&gt;
&lt;p&gt;to get the tag use &lt;code&gt;Element.tag&lt;/code&gt;, text: &lt;code&gt;Element.text&lt;/code&gt;
to get the number of children use &lt;code&gt;len(Element)&lt;/code&gt;
to get all children use &lt;code&gt;list(Element)&lt;/code&gt; and then you can slice and index to get a specific &lt;code&gt;SubElement&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If you want to add a new Element you can use &lt;code&gt;Subelement(parent, "tag of new")&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;To remove, append and insert use:
1. &lt;code&gt;Element.append(Element)&lt;/code&gt;
2. &lt;code&gt;Element.insert(0, Element)&lt;/code&gt;
3. &lt;code&gt;Element.remove(Element)&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Simple Navigation&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;lxml.etree&lt;/code&gt; supports the simple path syntax of &lt;strong&gt;find(), findall() and findtext()&lt;/strong&gt; on &lt;code&gt;ElementTree&lt;/code&gt; and &lt;code&gt;Element&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Xpath&lt;/h2&gt;
&lt;p&gt;Using Xpath you can navigate using the tree structure. You use it by &lt;code&gt;etree.xpath('/foo/bar')&lt;/code&gt; and the result is either text or Elements. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you apply it to ElementTree it performs a global query against the document (absolute) or root node (relative).&lt;br&gt;
If you apply it to an Element the XPath expression is evaluated against the Element (if relative) or against the root tree (if absolute)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I will expand on the Xpath syntax.&lt;/p&gt;
&lt;h3&gt;Elements&lt;/h3&gt;
&lt;p&gt;Xpath recognizes the following components of an Element:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;No.&lt;/th&gt;
&lt;th align="center"&gt;Expression&lt;/th&gt;
&lt;th align="left"&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;01.&lt;/td&gt;
&lt;td align="center"&gt;node-name&lt;/td&gt;
&lt;td align="left"&gt;Select all nodes with the given &amp;lt;node-name&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;02.&lt;/td&gt;
&lt;td align="center"&gt;/&lt;/td&gt;
&lt;td align="left"&gt;Selection starts from the root node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;03.&lt;/td&gt;
&lt;td align="center"&gt;//&lt;/td&gt;
&lt;td align="left"&gt;Selection starts from the current node that match selection&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;04.&lt;/td&gt;
&lt;td align="center"&gt;.&lt;/td&gt;
&lt;td align="left"&gt;Selects the current node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;05.&lt;/td&gt;
&lt;td align="center"&gt;..&lt;/td&gt;
&lt;td align="left"&gt;Selects the parent of the current node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;06.&lt;/td&gt;
&lt;td align="center"&gt;@&lt;/td&gt;
&lt;td align="left"&gt;Selects the attributes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;If you use:
&lt;code&gt;/node1/element&lt;/code&gt; selects the element within the root node "node1"&lt;/p&gt;
&lt;h3&gt;Axes&lt;/h3&gt;
&lt;p&gt;If you have selected a node using absolute or relative paths you can then identify other elements based by their relationship. &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;No.&lt;/th&gt;
&lt;th align="center"&gt;Expression&lt;/th&gt;
&lt;th align="left"&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;01.&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;ancestor&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;Represents the ancestors of the current node which include the parents up to the root node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;02.&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;ancestor-or-self&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;Represents the current node and it's ancestors&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;03.&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;attribute&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;Represents the attributes of the current node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;04.&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;child&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;Represents the children of the current node. if you type &lt;code&gt;xyz&lt;/code&gt; then this is short for &lt;code&gt;child::xyz&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;05.&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;descendant&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;Represents the descendants of the current node. Descendants include the node's children upto the leaf node (no more children)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;06.&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;descendant-or-self&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;Represents the current node and it's descendants&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;07.&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;following&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;Represents all nodes that come after the current node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;08.&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;following-sibling&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;Represents the following siblings of the context node. Siblings are at the same level as the current node and share it's parent&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;09.&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;namespace&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;Represents the namespace of the current node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10.&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;Represents the parent of the current node, shorthand &lt;code&gt;..&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11.&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;preceding&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;Represents all nodes that come before the current node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12.&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;self&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;Represents the current node, shorthand: &lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Zie hier de Axes visueel overzicht:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Axes overview" src="/images/xml_graph_1.gif"&gt;&lt;/p&gt;
&lt;p&gt;source: &lt;a href="https://images.app.goo.gl/nERDXvRxVcaVuWeM6"&gt;https://our.umbraco.com/documentation/reference/templating/macros/xslt/Images/7x1B0.gif&lt;/a&gt;
Because it might not be entirely clear what following and preceding means. I also found this chart:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Detailed Overview" src="/images/XML_axes_2.png"&gt;&lt;/p&gt;
&lt;p&gt;source: &lt;a href="https://images.app.goo.gl/pV1r4nNgcxKvunTa6"&gt;https://www.researchgate.net/profile/Pierre_Geneves/publication/29646041/figure/fig3/AS:667841837690890@1536237310303/XPath-Axes-Partition-from-Context-Node.png&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Operators&lt;/h3&gt;
&lt;p&gt;You can use the standard ...:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;comparison operators&lt;/strong&gt; in XPath &lt;code&gt;('=', '!=', '&amp;lt;', '&amp;gt;', '&amp;lt;=', &amp;gt;=, )&lt;/code&gt;. &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Boolean operators&lt;/strong&gt; are available &lt;code&gt;('and', 'or', 'not()')&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;numerical operations&lt;/strong&gt; &lt;code&gt;('+', '-', '*', 'div', 'mod')&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;math functions&lt;/strong&gt; &lt;code&gt;(celing(), floor(), round(), sum())&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;string functions&lt;/strong&gt; see table 1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;node functions&lt;/strong&gt; see table 2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Table 1:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;No.&lt;/th&gt;
&lt;th align="center"&gt;Function&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;starts-with(str1, str2)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Returns true when string starts with the second string&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;contains(str1, str2)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Returns true when the first string contains the second string&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;substring(str, offset, length)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Returns a section of the string. The section starts at offset up to the length provided&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;substring-before(str1, str2)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Returns the part of str1 up before the first occurence of str2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;substring-after(str1, str2)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Returns the part of str1 after the first occurence of str2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;string-length(str)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Returns the length of string in terms of characters&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;normalize-space(str)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Trims the leading and trailing space from string&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;translate(str1, str2, str3)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Returns the str1 after any matching chacters in str2 have been replaced by the characters in str3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;concat(str1, str2, ...)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Concatenates all strings&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;format-number(num1, str1, str2)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Returns a formatted version of num1 after applying str1 as a format string. Str2 is a locale string (optional)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;replace(str1, re_expr, str2)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Returns the value of the first str with every substring matched by the RE that is the value of the second argument replaced by the replacement string of the third arg.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;matches(str1, re_exp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;returns a boolean that indicates whether the value of the first argument is matched by the re of the 2nd arg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;tokenize(str1, re_exp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;returns a sequence of one or more strings whose values are substrings of the value of the first argument seperated by substrings that the RE that is the value of the 2nd argument.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Table 2:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;No.&lt;/th&gt;
&lt;th align="center"&gt;Operator&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Short for&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;used to select node under a specific node&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;//&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;used to select node from root node&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/descendat-or-self::node()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;[...]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;used to check node value&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;used for union of two node sets&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Table 3:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;No.&lt;/th&gt;
&lt;th align="center"&gt;Function&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;comment()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;selects nodes which are comments&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;node()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;slects all kinds of nodes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;processing-instruction()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;selects nodes which are processing instruction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;text()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;selects a text node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;name()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;provides the name of the node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;position()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;provides the position of the node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;last()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;selects the last node relative to current node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;distinct-values()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;returns the distinct values of the given element; e.g. &lt;code&gt;distinct-values(/*/*/name(.))&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Table 4: Wildcards in expressions:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;No.&lt;/th&gt;
&lt;th align="center"&gt;Function&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Short for&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;used to match any node&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;used to match the current node in context&lt;/td&gt;
&lt;td&gt;&lt;code&gt;self::node()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;@*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;used to match any attribute&lt;/td&gt;
&lt;td&gt;&lt;code&gt;attribute::name&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;node()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;used to match node of any type&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;..&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;parent of node&lt;/td&gt;
&lt;td&gt;&lt;code&gt;parent::node()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td align="center"&gt;&lt;code&gt;//&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;wildcard location&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Examples with Predicates&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;/class/student[1]&lt;/code&gt;: select the first student element which is child of class element&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/class/student[last()]&lt;/code&gt;: select the last student element which is child of class element&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/class/student[@rollno = 493]&lt;/code&gt;: select the student element with rollno attribute is 493&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class/student[marks&amp;gt;85]&lt;/code&gt;: select student element with marks &amp;gt;85&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;LXML and XPath&lt;/h3&gt;
&lt;p&gt;Wihin lxml you can use the &lt;code&gt;xpath()&lt;/code&gt; method in conjunction with variables to make queries more dynamic. For example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;//*[local-name() = $name]&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# prints the tag of the first child of node foo&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xpath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Also, the XPath code assumes the namespace is default. This is usually not the case. in that case you need to use &lt;code&gt;local-name()&lt;/code&gt; which ignores the namespace and returns the query results as if the XML did not have any namespace.&lt;/p&gt;
&lt;h3&gt;Tree Navigation&lt;/h3&gt;
&lt;p&gt;Using the tooling above it is very convenient to navigate the XML tree structure. For example if you want to use the text of the parent node of the a node with attribute xyz, you can use the following one-liner:
&lt;code&gt;../div[@id="xyz"]/text()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;you can also pass these nodes around as objects in python by using:
&lt;code&gt;object = find("//div[@id="xyz"]")&lt;/code&gt;
&lt;code&gt;parent = object.find("..")&lt;/code&gt;
&lt;code&gt;same_object = object.find(".")&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Using the text / math functions you can write things as
&lt;code&gt;//div[contains@id, "yz"]&lt;/code&gt; or
&lt;code&gt;//a[@href="something"]/img[starts-with(@src, "object")]&lt;/code&gt;
the first one results one or more divs where id contains the substring yz, where as the second returns the images where the source starts with object when there is a link to something on them.&lt;/p&gt;
&lt;p&gt;Link to Pydata talk:
&lt;a href="https://www.youtube.com/watch?v=WswN2V9D2rQ"&gt;YouTube&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In this talk the pythonic is compared with XPath when using XMLs. Assume a table in html &lt;code&gt;&amp;lt;table&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&lt;/code&gt; etc with four rows of data&lt;/p&gt;
&lt;p&gt;If you want to use python to find one specific row you would start iterating; this is not efficient as you need to loop through everything multiple times even:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;tables&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;td&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;# do something&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;td&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;content&amp;quot;&lt;/span&gt;
      &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;td&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;td&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;
      &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Next you can use Beautiful Soup; which makes the code more readible, and can use the hierarchic structure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;soup&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BeautifulSoup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;page&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;tableentries&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;soup&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_all&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;td&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;entry&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;tableentries&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;entry&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_text&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;value&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;entry&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;
      &lt;span class="n"&gt;children&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findChildren&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="n"&gt;theChild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;children&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;#assume value in 2nd col&lt;/span&gt;
      &lt;span class="n"&gt;reutrn&lt;/span&gt; &lt;span class="n"&gt;theChild&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Using XPath this compares to. This is the cleanest implementation of the parser IMHO:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;our_tree&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lxml&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;etree&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;our_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;//td[text()=&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;]/../td[position()=2]/text()&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;ele&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;our_tree&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xpath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;our_path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Advanced Examples:&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Some_odd_relative = parent_node.xpath(‘../..//new_tag[@src=’foo’]/@val’)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;find higher in the structure items with new_tage where the source is foo and give the val attribute.&lt;/p&gt;</content><category term="xml"></category><category term="lxml"></category><category term="python"></category><category term="xpath"></category></entry></feed>